#include "ros/ros.h"
#include <sstream>
#include "std_msgs/String.h"
#include "serial/serial.h"
#include "geometry_msgs/Twist.h"
#include "driver_HDC2450.h"
#include "sensor_msgs/BatteryState.h"
#include "math.h"
#include "geometry_msgs/Point.h"

void Velocidade_motor_rpm(const geometry_msgs::Twist::ConstPtr& velocidade);
void Set_Position(const std_msgs::String::ConstPtr& position);
void Dados_hulk();
void hulk_odometria();

//Variáveis Globais
const float PI = 3.141592654;
float L = 0.42; // distância entre as rodas
float R = 0.075; // raio das rodas
float vd_rad;
float ve_rad;
int vd_rpm = 0; // velocidade da roda direita em rpm
int ve_rpm = 0; // velocidade da roda esquerda em rpm

//Orientation and Translation
float x = 0;
float y = 0;
float theta = 0;

std::string porta = "/dev/ttyACM0";

Driver HULK;

sensor_msgs::BatteryState hulk_dados;

int main(int argc, char **argv)
{
	std_msgs::String velocidade;
	std_msgs::String position;
	geometry_msgs::Point odom;
	geometry_msgs::Point v_hulk; //ve_rpm --> x and vd_rpm --> y

	ros::init(argc,argv,"hulk_node");
	ros::NodeHandle n;
	ros::NodeHandle n_private("~");

	ros::Publisher info_velocity = n_private.advertise<geometry_msgs::Point>("read_speed",1000);
	ros::Publisher info_battery = n_private.advertise<sensor_msgs::BatteryState>("battery_info",1000);
	ros::Publisher info_odom = n_private.advertise<geometry_msgs::Point>("odometria",1000);

	ros::Subscriber get_velocity = n.subscribe("/hulk_move/speed",1000,Velocidade_motor_rpm);	
	
	n_private.getParam("porta_serial",porta);	
	
	HULK.serial_open(porta);
	
	ros::Rate freq(20);

	ros::Time current_time;

	while(ros::ok()){
	current_time = ros::Time::now();

	HULK.read();
	Dados_hulk();
	hulk_odometria();

	odom.x = x;
	odom.y = y;
	odom.z = theta;

    v_hulk.x = HULK.read_ve();
    v_hulk.y = HULK.read_vd();
  
	info_odom.publish(odom);
	info_velocity.publish(v_hulk);
	info_battery.publish(hulk_dados);

	ros::spinOnce();
	
	freq.sleep();
	}

return 0;
}

//Realizando o cáculo das velocidades de cada motor em rpm
void Velocidade_motor_rpm(const geometry_msgs::Twist::ConstPtr& velocidade){
	float v = velocidade->linear.x;
	float w = velocidade->angular.z;
		
	vd_rad = (2*v+w*L)/(2*R);
        ve_rad = (2*v-w*L)/(2*R);

	vd_rpm = (vd_rad*60/(2*PI));
	ve_rpm = (ve_rad*60/(2*PI));
	
	//std::cout<<"Velocidade roda direita = "<<vd_rpm<<"\nVelocidade roda esquerda = "<<ve_rpm<<std::endl;
	HULK.set_speed(vd_rpm,ve_rpm);
}

void Dados_hulk(){
	
	hulk_dados.voltage = HULK.read_volt_bat();
	hulk_dados.current = (HULK.read_current_d()*1000+HULK.read_current_e()*10);
	hulk_dados.percentage = (HULK.read_volt_bat()/24)*100.0;
	
}
	
void hulk_odometria(){
	float Ve_rpm = 0;
	float Vd_rpm = 0;
	float Ve_rad = 0;
	float Vd_rad = 0;
	float ve_m = 0;
	float vd_m = 0;
	float dt = 1/20.0;

	// recebendo as velocidades das rodas em rpm
	Ve_rpm = HULK.read_ve();
	Vd_rpm = HULK.read_vd();
	// dt = 1/f ; f=20Hz

	// conversão para rad/s
	Ve_rad = (Ve_rpm*2*PI)/60;
	Vd_rad = (Vd_rpm*2*PI)/60;
	
	// conversão para m/s
	ve_m = Ve_rad*R;
	vd_m = Vd_rad*R;

	// cálculo de theta
	// obs: curva para direita -> w<0 ; curva para esquerda -> w>0
	theta = theta + ((vd_m - ve_m)/L)*dt;

	// cálculo de X e Y
	x = x + ((ve_m + vd_m)/2)*cos(theta)*dt;
	y = y + ((ve_m + vd_m)/2)*sin(theta)*dt;
}	
	


